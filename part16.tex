\section{NP-полные задачи}
Определение классов P и NP.
Полиномиальные сведения.
NP-полнота задачи выполнимости булевой схемы.
Сведение CircuitSAT к SAT.
Сведение SAT к 3SAT.
Сведение 3SAT к IndependentSet.
Сведение IndependentSet к VertexCover и Clique.
Неразрешимость Halting Problem.

\subsection{Конспект}
Задача поиска полиномиально сводится к задаче проверки существования.
Сначала проверяем существование без ограничений,
потом ограничиваем первый бит,
потом второй, и т.д.

Задачи P (polynomial) --- у которых существует
полиномиальный алгоритм решения.

Задачи NP (non-deterministic polynomial) --- у которых существует
полиномиальный алгоритм проверки решения
(и решение полиномиального размера от входа).
Проверяемое решение --- <<сертификат>> (подсказка).

Пример P: эйлеров цикл.
Пример NP: гамильтонов цикл.

NP-hard --- к задаче можно полиномиально свести любую из NP.
Например, проблема останова --- NP-hard.
NP-complete --- NP-hard, находящаяся в NP.

Неизвестно, возможно ли решить
SAT (Satisfiability) быстрее $\O*(2^n) = \O(2^n \cdot Poly(n))$.
Можно решить k-SAT за $\O(2^{\varepsilon_k n}) \mid \varepsilon_k < 1$.
Для k = 2 существует линейное решение.

SAT => 3-SAT: возьмём конъюнктивную нормальную форму
\[
    (x_1 \lor \ldots \lor x_n) \land \ldots
    \Leftrightarrow
    (x_1 \lor x_2 \lor y_1) \land
    (\lnot y_1 \lor x_3 \lor y_2) \land \ldots \land
    (\lnot y_{n - 2} \lor x_{n - 1} \lor x_n) \land \ldots
\]
Если хотя бы один $x_i$ положителен,
то от него распространяются $y_j$ влево и вправо.
Если нет, то нельзя найти $y_j$, чтобы выражение выполнялось.

3SAT в независимое множество:
сделаем группы вершин (не соединённых),
соответствующих всем конъюнктам.
Вершины --- литералы,
рёбра --- между литералами одного конъюнкта
и между $x$ и $\lnot x$.
Тогда решением 3SAT было бы независимое множество
такого же размера, как количество конъюнктов.

Vertex Cover: если нашли вершинное покрытие,
то оставшиеся вершины --- независимое множество,
и наоборот.
Поэтому вершинное покрытие --- инверсия независимого множества.

Clique: независимое множество в графе
--- это клика в дополнении этого графа,
и наоборот.

Проблема останова неразрешима:
пронумеруем все алгоритмы,
пусть алгоритм $A$ определяет,
завершится ли алгоритм $B$ на входе $C$.
Тогда найдём алгоритм $D$,
который берёт некоторый ввод $E$,
запускает алгоритм $A$ с $B = C = E$
и инвертирует результат.
Запустим $D(D)$.
Если $A$ говорит, что $D(D)$ должен завершиться,
то $D$ не завершится, а если наоборот, то должен.
Следовательно, парадокс.
