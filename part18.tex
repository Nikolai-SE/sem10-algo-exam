\section{Альтернативные модели вычисления}
Модель внешней памяти.
Сортировка слиянием в модели внешней памяти.
Модель cache-oblivious.
Модель PRAM, вычисление максимума за константу.
Модель BSP.
Сортировка методом регулярного сэмплирования.

\subsection{Внешняя память}
Есть маленькая внутренняя память размера $M$ и диск.
Диск разбит на блоки размера $B$, чтение-запись --- поблочно.

Сложность будем мерять в количестве операций ввода-вывода.

Алгоритм в модели внешней памяти назовём эффективным,
задача в RAM-машине задача решается за $\O(f(N))$ шагов,
а со внешней памятью алгоритм решает её за $\O(f(N / B))$ шагов.

Пример 1 --- последовательный поиск значения в массиве.

Пример 2 --- двоичный поиск. В RAM --- $\O(\log N)$,
если на диске храним B-дерево, то $\O(\log_B N)$.

Пример 3 --- сортировка слиянием.
Читаем по 2 блока исходного массива,
сортируем их в памяти, записываем обратно.
Потребуется $4B$ памяти,
сложность итерации --- $N / B$
потребуется $\log_2 (N / B)$ итераций,
сложность --- $\O((N/B) \log (N/B))$.
Алгоритм эффективен.

Можно сортировать слиянием быстрее,
если делить не по 2, а по $k$.
Возьмём $k = \floor{M / B} - 1$,
тогда сложность --- $\O(\frac{N}{B} \log_{\frac{M}{B}} \frac{N}{B})$.
На обычной RAM-машине сложность была бы
$\O(k N \log_k N)$,
т.к. нужно выбирать максимум из $k$ элементов.

\begin{definition}
    Модель называется cache oblivious,
    если $B$ и $M$ неизвестны,
    управление кешем --- вне доступа, автоматически.
\end{definition}
\begin{definition}
    Иначе --- cache aware.
\end{definition}
\begin{definition}
    Если алгоритм остаётся эффективным --- cache friendly.
\end{definition}

Существует cache oblivious сортировка за ту же асимптотику.

\subsection{Параллельные вычисления (PRAM)}
$P$ процессоров, единая RAM.
Сложность --- самое долгое время исполнения потока.
Обычно процессоров $\O(1)$, что не интересно,
т.к. даёт только константное ускорение.

Варианты взаимодействия с памятью:
\begin{itemize}
    \item EREW --- Exclusive Read, Exclusive Write
    \item CREW --- Concurrent Read, Exclusive Write
    \item CRCW --- Concurrent Read, Concurrent Write
\end{itemize}

\subsection{Максимум за константу}
$P = \Omega(N^2)$, синхронизируемые шаги:
\begin{enumerate}
    \item Первые $N$ процессоров записывают $c[i] \gets 1$
    \item Процессор с номером $in + j$ сравнивает $a[i]$ и $a[j]$,
    если $a[i] < a[j]$, то $c[i] \gets 0$
    \item Первые $N$ процессоров сравнивают $c[i]$ с 1,
    если $c[i] = 1$, то $\text{ответ} \gets a[i]$
\end{enumerate}

\subsection{BSP}
Bulk Synchronous Parallel
\begin{itemize}
    \item $P$ процессоров со своей RAM, операция за 1
    \item Сообщение от одного процессора другому и общение с внешней памятью за $G$
    \item Барьерная синхронизация --- $L$ времени
\end{itemize}

Процесс выполнения:
\begin{enumerate}
    \item Вход во внешнюю память
    \item Вычисление разбито на супершаги (раунды)
    \item Раунд:
    \begin{itemize}
        \item Операции процессоров в своей памяти
        \item Коммуникация и взаимодействие с внешней памятью,
        время на отправку сообщения и ввод-вывод --- $G$
        \item Барьерная синхронизация за время $L$
    \end{itemize}
\end{enumerate}

Процессор $p$ на раунде $s$
делает $comp(s, p)$ операций,
отправляет $comm(s, p)$ значений.

\[ comp(s) = \max_p comp(s, p) \]
\[ comm(s) = \max_p comm(s, p) \]

\[ cost(s) = comp(s) + G \cdot comm(s) + L \]
\[ cost = \sum cost(s) = comp + comm + L \cdot sync \]

\subsection{Сортировка методом регулярного сэмплирования}
\[ N = \Omega(P^3) \]

\begin{enumerate}
    \item Каждый процессор сортирует свой отрезок размера $N / P$
    и разбивает его на $P$ блоков размера $N / P^2$
    \item Отдельный процессор берёт все
    $P^2$ границ блоков и сортирует их,
    затем берёт $P$ разделителей, тем самым определяя
    $P$ неравных бакетов в массиве,
    затем рассылает разделители всем процессорам
    \item Каждый процессор получает разделители
    и номер бакета, сканирует свой отрезок
    и посылает его элементы процессорам, ответственным
    за соответствующие бакеты.
    Затем получает свои элементы, и записывает их.
    \item Каждый процессор сортирует свой бакет
    и посылает его размер первому процессору.
    \item Отдельный процессор вычисляет
    отступы бакетов и рассылает их процессорам.
    \item Каждый процессор записывает свой бакет
    во внешнюю память.
\end{enumerate}

\begin{theorem}
    Размер каждого бакета не более $2N / P$.
\end{theorem}
\begin{proof}
    Выделим бакет.
    Назовём блок левым или правым по тому,
    как относится его левая граница к
    левой границе этого бакета.

    У каждого процессора есть не более одного левого блока,
    пересекающегося с бакетом, т.к. все блоки левее него
    уже не будут пересекаться.

    Среди всех процессоров есть не более $P$
    правых блоков, пересекающихся с бакетом,
    т.к. их левые границы были между левой
    и правой границами бакета при распределении.

    Тогда всего бакет содержит элементы
    из не более чем $2P$ блоков,
    а каждый блок имеет размер $N / P^2$,
    следовательно, всего
    --- не более $2N / P$ элементов в бакете.
\end{proof}

Тогда сложность третьего раунда:
\[
    comp
    = \O \parens{\frac{N}{P} + \frac{2N}{P}}
    = \O \parens{\frac{N}{P}}
\]
\[
    comm
    = \O \parens{\frac{N}{P}}
\]

Всего:
\[
    comp
    = \O \parens{\frac{N}{P} \log \frac{N}{P} + \frac{N}{P} \log P}
    = \O \parens{\frac{N \log N}{P}}
\]
\[
    comm
    = \O \parens{P^2 + \frac{N}{P}}
    = \O \parens{\frac{N}{P}}
\]
\[ sync = \O(1) \]
